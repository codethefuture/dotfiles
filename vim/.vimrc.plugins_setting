
function! s:bundle_tap(bundle) " {{{
  let s:tapped_bundle = neobundle#get(a:bundle)
  return neobundle#is_installed(a:bundle)
endfunction " }}}

function! s:bundle_config(config) " {{{
  if exists("s:tapped_bundle") && s:tapped_bundle != {}
    call neobundle#config(s:tapped_bundle.name, a:config)
  endif
endfunction " }}}

function! s:bundle_untap() " {{{
  let s:tapped_bundle = {}
endfunction " }}}

"------------------------------------
" vim-singleton
"------------------------------------

"call singleton#enable()

"------------------------------------
" vim-quickrun
"------------------------------------
let g:quickrun_config = {}
let g:quickrun_config._ = { 'runner' : 'vimproc' }
let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec', 'split': '' }
"let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec', 'cmdopt': 'bundle exec', 'exec': '%o %c %s' }
let g:quickrun_config['markdown'] = {
    \ 'command' : 'pandoc',
    \ 'exec': ['%c -s -f markdown -t html -o %s:p:r.html %s', 'w3m %s:p:r.html', 'sleep 1', 'rm %s:p:r.html'],
    \ 'outputter': 'browser',
    \ 'cmdopt': '-s',
    \ 'tempfile': '{tempname()}.md' }

augroup QuickrunRSpec
  autocmd!
  autocmd BufWinEnter,BufNewFile *_spec.rb set filetype=ruby.rspec
augroup END

"------------------------------------
" vim-proc
"------------------------------------

if has('mac')
  let g:vimproc_dll_path = $VIMRUNTIME . '/autoload/vimproc_mac.so'
elseif has('win32')
  let g:vimproc_dll_path = $HOME . '.vim/bundle/vimproc/autoload/vimproc_win32.dll'
elseif has('win64')
  let g:vimproc_dll_path = $HOME . '.vim/bundle/vimproc/autoload/vimproc_win64.dll'
endif

"------------------------------------
" unite.vim
"------------------------------------
if s:bundle_tap('unite.vim') " {{{
  call s:bundle_config({
        \   'autoload' : {
        \     'commands' : [
        \       {
        \         'name' : 'Unite',
        \         'complete' : 'customlist,unite#complete_source'
        \       },
        \       'UniteWithCursorWord',
        \       'UniteWithInput'
        \     ]
        \   }
        \ })

  function! s:tapped_bundle.hooks.on_source(bundle)
    " settings
    " 入力モードで開始する
    hi UniteCursorLine ctermbg=236   cterm=none
    let g:unite_cursor_line_highlight='UniteCursorLine'
    let g:unite_data_directory=g:my.dir.unite
    let g:unite_enable_split_vertically=0
    let g:unite_update_time=50
    let g:unite_enable_start_insert=1
    let g:unite_source_directory_mru_limit = 200
    let g:unite_source_directory_mru_time_format="(%m-%d %H:%M) "
    let g:unite_winheight=15
    let g:unite_source_file_mru_time_format="(%m-%d %H:%M) "
    let g:unite_source_file_mru_filename_format=":~:."
    let g:unite_source_file_mru_limit = 300
    let g:unite_winheight = 20
    let g:unite_marked_icon = "✓"
    let g:unite_force_overwrite_statusline=1
    let g:unite_source_history_yank_enable = 0
    let s:unite_kuso_hooks = {}
    "bookmarkだけホームディレクトリに保存
    "let g:unite_source_bookmark_directory = $HOME . '/.unite/bookmark'
    let s:unite_kuso_hooks = {}

    function! s:unite_my_settings()
      " インサート／ノーマルどちらからでも呼び出せるようにキーマップ
      " ファイル一覧
      nnoremap <silent> ,uf :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
      nnoremap <silent> <C-f> :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
      inoremap <silent> <C-f> <ESC>:<C-u>UniteWithBufferDir -buffer-name=files file<CR>
      " 常用セット
      nnoremap <silent> ,uu :<C-u>Unite buffer file_mru<CR>
      nnoremap <silent> <C-b> :<C-u>Unite buffer file_mru<CR>
      inoremap <silent> <C-b> <ESC>:<C-u>Unite buffer file_mru<CR>
      " バッファ一覧
      nnoremap <silent> ,ub :<C-u>Unite buffer<CR>
      " レジスタ一覧
      nnoremap <silent> ,ur :<C-u>Unite -buffer-name=register register<CR>
      " 最近使用したファイル一覧
      nnoremap <silent> ,um :<C-u>Unite file_mru<CR>
      " 全部乗せ
      nnoremap <silent> ,ua :<C-u>UniteWithBufferDir -buffer-name=files buffer file_mru bookmark file<CR>
      "ブックマーク一覧
      nnoremap <silent> ,uc :<C-u>Unite bookmark<CR>
      "ブックマークに追加
      nnoremap <silent> ,ua :<C-u>UniteBookmarkAdd<CR>

      " 単語単位からパス単位で削除するように変更
      imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
      " ESCキーを2回押すと終了する
      "nmap <silent><buffer> <ESC><ESC> q
      "imap <silent><buffer> <ESC><ESC> <ESC>q
      " Ctrl-cキーを押すと終了する
      nmap <silent><buffer> <C-c> q
      imap <silent><buffer> <C-c> <C-c>q

      " inoremap <silent><buffer><C-J> <Plug>(unite_loop_cursor_down)
      " inoremap <silent><buffer><C-K> <Plug>(unite_loop_cursor_up)
      nmap     <silent><buffer>f <Plug>(unite_toggle_mark_current_candidate)
      xmap     <silent><buffer>f <Plug>(unite_toggle_mark_selected_candidates)
      nmap     <silent><buffer><C-H> <Plug>(unite_toggle_transpose_window)
      nmap     <silent><buffer>p <Plug>(unite_toggle_auto_preview)
      nnoremap <silent><buffer><expr>S unite#do_action('split')
      nnoremap <silent><buffer><expr>V unite#do_action('vsplit')
      nnoremap <silent><buffer><expr>,, unite#do_action('vimfiler')
      nnoremap <silent><buffer>C gg0wC
      nnoremap <expr><buffer>re unite#do_action('replace')

      " ウィンドウを分割して開く
      au FileType unite nnoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
      au FileType unite inoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
      " ウィンドウを縦に分割して開く
      au FileType unite nnoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
      au FileType unite inoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
      " ESCキーを2回押すと終了する
      au FileType unite nnoremap <silent> <buffer> <ESC><ESC> q
      au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>q

      syntax match uniteSource__FileMru_Dir /.*\// containedin=uniteSource__FileMru contains=uniteSource__FileMru_Time,uniteCandidateInputKeyword nextgroup=uniteSource__FileMru_Dir

      setl nolist
      setl cursorline
      highlight link uniteMarkedLine Identifier
      highlight link uniteCandidateInputKeyword Statement

      highlight link uniteSource__FileMru_Dir Directory
      highlight link uniteSource__FileMru_Time Comment
    endfunction
    function! s:unite_kuso_hooks.file()
      inoremap <buffer><Tab> <CR>
      syntax match uniteFileDirectory '.*\/'
      highlight link uniteFileDirectory Directory
    endfunction
    function! s:unite_kuso_hooks.versions_log()
      nnoremap <silent><buffer><expr>c unite#do_action('changeset')
      nnoremap <silent><buffer><expr>cp unite#do_action('changeset_prev')
      nnoremap <silent><buffer><expr>d unite#do_action('diff')
      nnoremap <silent><buffer><expr>diff_prev unite#do_action('diff_prev')
      nnoremap <silent><buffer><expr>r unite#do_action('yank_revision')
      nnoremap <silent><buffer><expr>rv unite#do_action('revert')
      nnoremap <silent><buffer><expr>rsh unite#do_action('reset_hard')
      nnoremap <silent><buffer><expr>rss unite#do_action('reset_soft')
    endfunction

    call s:unite_my_settings()

  endfunction

  " For ack.
  if executable('sg')
    let g:unite_source_grep_command = 'sg'
    let g:unite_source_grep_default_opts =
          \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
          \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_max_candidates = 200
  elseif executable('ag')
    " Use ag in unite grep source.
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts =
          \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
          \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_max_candidates = 200
  elseif executable('ack-grep')
    " For ack.
    let g:unite_source_grep_command = 'ack-grep'
    let g:unite_source_grep_default_opts = '--no-heading --no-color -a'
    let g:unite_source_grep_recursive_opt = ''
  endif

  "------------------------------------
  " unite-reek, unite-rails_best_practices
  "------------------------------------

  nnoremap <silent> <C-H><C-R> :<C-u>Unite -no-quit reek<CR>
  nnoremap <silent> <C-H><C-R><C-R> :<C-u>Unite -no-quit rails_best_practices<CR>

  call s:bundle_untap()
endif " }}}

"------------------------------------
" vim-rails
" unite-rails.vim
"------------------------------------
if s:bundle_tap('rails.vim') " {{{
  call s:bundle_config({
        \ 'depends' : 'Shougo/unite.vim',
        \   'autoload' : {
        \   'unite_sources' : [
        \     'rails/bundle', 'rails/bundled_gem', 'rails/config',
        \     'rails/controller', 'rails/db', 'rails/destroy', 'rails/features',
        \     'rails/gem', 'rails/gemfile', 'rails/generate', 'rails/git', 'rails/helper',
        \     'rails/heroku', 'rails/initializer', 'rails/javascript', 'rails/lib', 'rails/log',
        \     'rails/mailer', 'rails/model', 'rails/rake', 'rails/route', 'rails/schema', 'rails/spec',
        \     'rails/stylesheet', 'rails/view'
        \   ]
        \   }
        \ })

  function! s:tapped_bundle.hooks.on_source(bundle)
    " let g:rails_ctags_arguments = ''
    " let g:rails_ctags_arguments='--languages=-javascript'
    " let g:rails_some_option = 1
    " let g:rails_statusline = 1
    " let g:rails_subversion=0
    let g:dbext_default_SQLITE_bin = 'mysql2'
    let g:rails_default_file='config/database.yml'
    let g:rails_gnu_screen=1
    let g:rails_level = 4
    let g:rails_mappings=1
    let g:rails_modelines=0
    let g:rails_syntax = 1
    let g:rails_url='http://localhost:3000'
  endfunction

  "noremap :rc :<C-u>Unite rails/controller<CR>
  "noremap :rm :<C-u>Unite rails/model<CR>
  "noremap :rv :<C-u>Unite rails/view<CR>
  "noremap :rh :<C-u>Unite rails/helper<CR>

  aug MyAutoCmd
    au User Rails call s:unite_rails_setting()
    "autocmd User Rails call s:unite_rails_setting()
    "call s:unite_rails_setting()
  aug END

  function! s:unite_rails_setting()
    call s:do_rails_autocmd()
    call s:set_up_rails_etting()
    call s:set_up_rails_setting()
    nnoremap <Space>r :R<CR>
    nnoremap <Space>a :A<CR>
    nnoremap <buffer>[plug]            :<C-U>UniteGit app/models<CR>
    nnoremap <buffer>[plug]<C-H>       :<C-U>UniteGit app/controllers<CR>
    nnoremap <buffer>[plug]<C-H><C-H>  :<C-U>UniteGit app/views<CR>
    nnoremap <buffer>[plug]c           :<C-U>UniteGit config<CR>
    nnoremap <buffer>[plug]j           :<C-U>UniteGit app/assets/javascripts<CR>
    nnoremap <buffer>[plug]a           :<C-U>UniteGit app/assets/stylesheets<CR>
    nnoremap <buffer>[plug]s           :<C-U>UniteGit spec<CR>
    nnoremap <buffer>[plug]d           :<C-U>UniteGit db<CR>
    nnoremap <buffer>[plug]i           :<C-U>UniteGit db/migrate<CR>
    nnoremap <buffer>[plug]f           :<C-U>UniteGit db/fixtures<CR>
    nnoremap <buffer>[plug]m           :<C-U>UniteGit app/mailers<CR>
    nnoremap <buffer>[plug]l           :<C-U>UniteGit lib<CR>
    nnoremap <buffer>[plug]p           :<C-U>UniteGit public<CR>
    nnoremap <buffer>[plug]g           :<C-U>UniteGit Gemfile<CR>
    nnoremap <buffer>[plug]r           :<C-U>UniteGit config/routes.rb<CR>
    " nnoremap <buffer>[plug]h           :<C-U>UniteGit rails/heroku<CR>
    nnoremap <buffer>[plug]h           :<C-U>UniteGit app/helpers<CR>
    nnoremap <buffer><silent>,cr  :<C-U>RSpecCurrent<CR>
    nnoremap <buffer><silent>,nr :<C-U>RSpecNearest<CR>
    nnoremap <buffer><silent>,lr :<C-U>RSpecRetry<CR>
    nnoremap <buffer><silent>,ar :<C-U>RSpecAll<CR>
  endfunction
  function! s:set_up_rails_etting()
    nnoremap <buffer><Space>r :R<CR>
    nnoremap <buffer><Space>a :A<CR>
    nnoremap <buffer><Space>m :Rmodel<Space>
    nnoremap <buffer><Space>c :Rcontroller<Space>
    nnoremap <buffer><Space>v :Rview<Space>
    nnoremap <buffer><Space>p :Rpreview<CR>
  endfunction
  function! s:do_rails_autocmd()
    if !exists("b:rails_root")
      return
    endif

    let buf = rails#buffer()
    let type = "-" . buf.type_name()
    let path = '/' . buf.name()
    if path =~ '[ !#$%\,]'
      let path = ''
    endif

    if type != '-'
      execute "silent doautocmd User Rails" . s:gsub(type, '-', '.')
    endif

    if path != ''
      execute "silent doautocmd User Rails" . path
    endif
  endfunction
  function! s:set_up_rails_setting()
    let buf = rails#buffer()
    let type_name = buf.calculate_file_type()
    let dict_name = "rails." . type_name
    set dict+=~/.vim/dict/ruby.rails.dict
    for s:syntax in split(glob($HOME.'/.vim/syntax/ruby.rails.*.vim'))
      execute 'source ' . s:syntax
    endfor
    execute 'nnoremap <buffer><Space><Space>d  :<C-U>Edit ~/.vim/dict/' . dict_name .'.dict<CR>'
    execute 'set dict+=~/.vim/dict/' . dict_name . '.dict'
  endfunction

  call s:bundle_untap()
endif " }}}

"------------------------------------
" 補間 neocomplete
"------------------------------------

" Use neocomplete.
let g:neocomplete#enable_at_startup = 1

if s:bundle_tap('neocomplete.vim') " {{{
"  call s:bundle_config({
"        \ 'depends' : 'Shougo/unite.vim',
"        \   'autoload' : {
"        \   'unite_sources' : [
"        \     'rails/bundle', 'rails/bundled_gem', 'rails/config',
"        \     'rails/controller', 'rails/db', 'rails/destroy', 'rails/features',
"        \   ]
"        \   }
"        \ })

  function! s:tapped_bundle.hooks.on_source(bundle)

  " Disable AutoComplPop.
  let g:acp_enableAtStartup = 0
  " Use smartcase.
  let g:neocomplete#enable_smart_case = 1
  " Set minimum syntax keyword length.
  let g:neocomplete#sources#syntax#min_keyword_length = 3
  let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

  let g:neocomplete#auto_completion_start_length=2
  " let g:neocomplete_caching_limit_file_size=500000
  " let g:neocomplete_max_keyword_width=120
  let g:neocomplete#auto_completion_start_length=g:neocomplete#sources#syntax#min_keyword_length
  let g:neocomplete#ctags_arguments=g:alpaca_tags_config
  let g:neocomplete#data_directory=g:my.dir.neocomplete
  let g:neocomplete#enable_auto_close_preview=0
  let g:neocomplete#enable_auto_select=0

  " let g:neocomplete#enable_refresh_always = 0
  " For auto select.
  let g:neocomplete#enable_complete_select = 0
  let g:neocomplete#enable_fuzzy_completion=0
  let g:neocomplete#force_overwrite_completefunc = 1
  let g:neocomplete#manual_completion_start_length=0

  let g:neocomplete#sources#buffer#cache_limit_size=700000
  let g:neocomplete#sources#tags#cache_limit_size=1000000
  let g:neocomplete#sources#include#max_proceslses = 30
  let g:neocomplete#max_list=100
  " let g:neocomplete#skip_auto_completion_time='0.1'

  " if g:neocomplete#enable_complete_select
  "   set completeopt-=noselect
  "   set completeopt+=noinsert
  " endif

  let g:neocomplete#disable_auto_select_buffer_name_pattern =
        \ '\[Command Line\]'

  call neocomplete#custom#source('tag', 'disabled', 1)
  call neocomplete#custom#source('vim', 'filetypes', { 'vim' : 1, 'vimconsole': 1})
  " file
  " file/include
  " dictionary
  " member
  " buffer
  " syntax
  " include
  " neosnippet
  " vim
  " omni
  " tag

  " for rsense
  let g:rsenseHome = expand("~/.bundle/rsense-0.3")
  let g:rsenseUseOmniFunc = 1
  " omnifuncいらねー。
  " autocmd MyAutoCmd FileType ruby set omnifunc=

  " for clang
  " libclang を使用して高速に補完を行う
  " let g:neocomplete_clang_use_library=1
  " clang.dll へのディレクトリパス
  " let g:neocomplete_clang_library_path='C:/llvm/bin'
  " clang のコマンドオプション
  " let g:neocomplete_clang_user_options =
  "     \ '-I C:/MinGW/lib/gcc/mingw32/4.5.3/include '.
  "     \ '-I C:/lib/boost_1_47_0 '.
  "     \ '-fms-extensions -fgnu-runtime '.
  "     \ '-include malloc.h '

  " initialize
  if $USER == 'root'
    let g:neocomplete#data_directory = '/tmp'
  endif

  let s:neocomplete_initialize_lists = [
        \ 'neocomplete#sources#include#patterns',
        \ 'neocomplete#sources#omni#functions',
        \ 'neocomplete#sources#omni#input_patterns',
        \ 'neocomplete#force_omni_input_patterns',
        \ 'neocomplete#keyword_patterns',
        \ 'neocomplete#sources#vim#complete_functions',
        \ 'neocomplete#delimiter_patterns',
        \ 'neocomplete#sources#dictionary#dictionaries',
        \ 'neocomplete#sources',
        \ 'neocomplete#text_mode_filetypes',
        \ ]
  endfunction

  for initialize_variable in s:neocomplete_initialize_lists
    call alpaca#let_g:(initialize_variable, {})
  endfor

  let g:neocomplete#text_mode_filetypes = {
        \ 'markdown' : 1,
        \ 'gitcommit' : 1,
        \ 'text' : 1,
        \ }

  let g:neocomplete#sources#omni#functions.java = 'eclim#java#complete#CodeComplete'

  " Define keyword pattern.
  let g:neocomplete#keyword_patterns = {
        \ '_' : '[0-9a-zA-Z:#_]\+',
        \ 'c' : '[^.[:digit:]*\t]\%(\.\|->\)',
        \ 'mail' : '^\s*\w\+',
        \ 'perl' : '\h\w*->\h\w*\|\h\w*::',
        \ }

  " Define include pattern.
  let g:neocomplete#sources#include#patterns = {
        \ 'scala' : '^import',
        \ 'scss'  : '^\s*\<\%(@import\)\>',
        \ 'php'   : '^\s*\<\%(inlcude\|\|include_once\|require\|require_once\)\>',
        \ }

  " Define omni input patterns
  " let g:neocomplete#sources#omni#input_patterns.ruby =
  "       \ '[^. *\t]\.\w*\|\h\w*::'
  let g:neocomplete#sources#omni#input_patterns.php =
        \ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
  let g:neocomplete#sources#omni#input_patterns.c =
    \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
  let g:neocomplete#sources#omni#input_patterns.cpp =
    \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

  " Define force omni patterns
  let g:neocomplete#force_omni_input_patterns.c      =
        \ '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplete#force_omni_input_patterns.cpp    =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
  let g:neocomplete#force_omni_input_patterns.objc   =
        \ '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplete#force_omni_input_patterns.objcpp =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

  " tags_completeはデフォルトでOFFでいい。。
  " keys(neocomplete#variables#get_sources())
  " let g:neocomplete#sources._ = ['file', 'tag', 'neosnippet', 'vim', 'dictionary', 'omni', 'member', 'syntax', 'include', 'buffer', 'file/include']
  " let g:neocomplete_disabled_sources_list._ = ['tags_complete']
  " let g:neocomplete_disabled_sources_list.vim = ['vimshell']
  " let g:neocomplete_disabled_sources_list.ruby = ['syntax', 'include', 'omni', 'file/include', 'member']
  " let g:neocomplete_disabled_sources_list.haml = g:neocomplete_disabled_sources_list.ruby
  " let g:neocomplete_sources_list = {
  "       \ 'unite': [],
  "       \ }
  " let g:neocomplete_disabled_sources_list._ = ['tags_complete', 'omni_complete']

  " neocomplete#custom#source(

  " let g:neocomplete_delimiter_patterns = {
  "       \ 'ruby' : []
  "       \ }

  " Define completefunc
  let g:neocomplete#sources#vim#complete_functions = {
        \ 'Ref' : 'ref#complete',
        \ 'Unite' : 'unite#complete_source',
        \ 'VimShellExecute' :
        \      'vimshell#vimshell_execute_complete',
        \ 'VimShellInteractive' :
        \      'vimshell#vimshell_execute_complete',
        \ 'VimShellTerminal' :
        \      'vimshell#vimshell_execute_complete',
        \ 'VimShell' : 'vimshell#complete',
        \ 'VimFiler' : 'vimfiler#complete',
        \ 'Vinarise' : 'vinarise#complete',
        \}

  " ファイルタイプ毎の辞書ファイルの場所
  let neocomplete#sources#dictionary#dictionaries = {
        \ 'default'             : '',
        \ 'javascript.timobile' : $HOME.'/.vim/dict/timobile.dict',
        \ 'coffee.timobile'     : $HOME.'/.vim/dict/timobile.dict',
        \ 'vimshell' : g:my.dir.vimshell . '/command-history',
        \ }

  for s:dict in split(glob($HOME.'/.vim/dict/*.dict'))
    let s:ft = matchstr(s:dict, '[a-zA-Z0-9.]\+\ze\.dict$')
    let neocomplete#sources#dictionary#dictionaries[s:ft] = s:dict
  endfor

  " キャッシュしないファイル名
  let g:neocomplete#sources#buffer#disabled_pattern = '\.log\|\.log\.\|\.jax'
  " 自動補完を行わないバッファ名
  let g:neocomplete#lock_buffer_name_pattern = '\.log\|\.log\.\|.*quickrun.*\|.jax'

  aug MyAutoCmd
    " previewwindowを自動で閉じる
    au BufReadPre *
          \ if &previewwindow
          \|  au BufEnter <buffer>
          \|  if &previewwindow
          \|    call <SID>smart_close()
          \|  endif
          \|endif
  aug END

  " Plugin key-mappings.

  imap <expr><C-G>          neocomplete#undo_completion()
  imap <C-K>  <Plug>(neocomplete_start_unite_complete)
  imap <expr><TAB>          neosnippet#expandable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplete#complete_common_string() : "\<TAB>"
  " imap <silent><expr><CR>   neocomplete#smart_close_popup() . "<CR>" . "<Plug>DiscretionaryEnd"
  function! s:my_crinsert()
    return neocomplete#close_popup() . "\<CR>"
    " return pumvisible() ? neocomplete#close_popup() . "\<CR>" : "\<CR>"
  endfunction
  inoremap <silent> <CR> <C-R>=<SID>my_crinsert()<CR>
  inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
  " inoremap <expr><C-n>      pumvisible() ? "\<C-n>" : "\<Down>"
  " inoremap <expr><C-p>      pumvisible() ? "\<C-p>" : "\<Up>"
  inoremap <expr><C-n>  pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>\<Down>"
  inoremap <expr><C-p>  pumvisible() ? "\<C-p>" : "\<C-p>\<C-n>"
  inoremap <expr><C-x><C-f>  neocomplete#start_manual_complete('file')
  inoremap <expr><C-g>     neocomplete#undo_completion()

  inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
  inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
  inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
  inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"

  " test
  inoremap <expr><TAB>  pumvisible() ? "\<C-n>" :
        \ <SID>check_back_space() ? "\<TAB>" :
        \ neocomplete#start_manual_complete()
  function! s:check_back_space()
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
  endfunction


  call s:bundle_untap()
endif " }}}

if s:bundle_tap('neocomplcache-rsense.vim') " {{{
  function! s:tapped_bundle.hooks.on_source(bundle)
    let g:neocomplete#sources#rsense#home_directory = neobundle#get_neobundle_dir() . '/rsense-0.3'
    " let g:neocomplete#sources#rsense#home_directory = "/usr/local/Cellar/rsense/0.3"
  endfunction
  call s:bundle_untap()
endif " }}}

"------------------------------------
" neosnippet
"------------------------------------

" neosnippet "{{{

" snippetを保存するディレクトリを設定してください
let s:default_snippet = neobundle#get_neobundle_dir() . '/neosnippet/autoload/neosnippet/snippets' " 本体に入っているsnippet
let s:my_snippet = '~/.vim/snipmate-snippets/snippets' " 自分のsnippet
let g:neosnippet#snippets_directory = s:my_snippet
let g:neosnippet#snippets_directory = s:default_snippet . ',' . s:my_snippet
imap <silent><C-F>                <Plug>(neosnippet_expand_or_jump)
inoremap <silent><C-U>            <ESC>:<C-U>Unite snippet<CR>
nnoremap <silent><Space>e         :<C-U>NeoSnippetEdit -split<CR>
smap <silent><C-F>                <Plug>(neosnippet_expand_or_jump)
" xmap <silent>o                    <Plug>(neosnippet_register_oneshot_snippet)
"}}}

"" Define dictionary.
"let g:neocomplcache_dictionary_filetype_lists = {
"  \ 'default' : '',
"  \ 'ruby' : $HOME.'/.vim/snippets/ruby.snippets',
"  \ 'erb' : $HOME.'/.vim/snippets/erb.snippets',
"  \ 'html' : $HOME.'/.vim/snippets/html.snippets',
"  \ 'css' : $HOME.'/.vim/snippets/css.snippets',
"  \ 'javascript' : $HOME.'/.vim/snippets/javascript.snippets'
"  \ }

"------------------------------------
" syntastic
"------------------------------------

if s:bundle_tap('vimfiler.vim') " {{{
  function! s:tapped_bundle.hooks.on_source(bundle)

      let g:syntastic_check_on_open=0 "ファイルを開いたときはチェックしない
      let g:syntastic_check_on_save=1 "保存時にはチェック
      let g:syntastic_auto_loc_list=1 "エラーがあったら自動でロケーションリストを開く
      let g:syntastic_loc_list_height=6 "エラー表示ウィンドウの高さ
      let g:syntastic_quiet_warnings = 0

      let g:syntastic_mode_map = {
        \ 'mode': 'passive',
        \ 'active_filetypes': [''
        \    ],
        \ 'passive_filetypes': [
        \       'ruby', 'slim', 'eruby',
        \       'javascript', 'html', 'css', 'scss', 'sass'
        \    ]
        \ }
      let g:syntastic_ruby_checkers = ['rubocop']

      "エラー表示マークを変更
      let g:syntastic_enable_signs=1
      let g:syntastic_error_symbol='✗'
      let g:syntastic_warning_symbol='⚠'

  endfunction

  noremap <C-s> :<C-u>:SyntasticCheck<CR>

  " gem install ruby-lint
  "au BufWritePost *.rb call RubyLint()
  "au BufWritePost *.erb call RubyLint()
  "au BufWritePost *.slim call RubyLint()
  "au FileType ruby noremap <C-l> :call RubyLint()<CR>

  function! RubyLint()
    let result = system( &ft . ' -c ' . bufname(""))
    echo result
  endfunction

  call s:bundle_untap()
endif " }}}

"------------------------------------
" html5.vim
" https://github.com/othree/html5.vim/blob/master/README.markdown
"------------------------------------
" Disable event-handler attributes support:
let g:html5_event_handler_attributes_complete = 0
" Disable RDFa attributes support:
let g:html5_rdfa_attributes_complete = 0
" Disable microdata attributes support:
let g:html5_microdata_attributes_complete = 0
" Disable WAI-ARIA attribute support:
let g:html5_aria_attributes_complete = 0

"-----------------------------------
" vimfiler.vim
"------------------------------------

if s:bundle_tap('vimfiler.vim') " {{{
  function! s:tapped_bundle.hooks.on_source(bundle)
    "data_directory はramdiskを指定
    if has('win32')
    elseif  has('macunix')
      let g:vimfiler_data_directory = $HOME . '/.vim/.vimfiler'
    else
      let g:vimfiler_data_directory = $HOME . '/.vimfiler'
    endif

    "vimデフォルトのエクスプローラをvimfilerで置き換える
    let g:vimfiler_as_default_explorer = 1
    "セーフモードを無効にした状態で起動する
    let g:vimfiler_safe_mode_by_default = 0
    "現在開いているバッファのディレクトリを開く
    nnoremap <silent> <Leader>fe :<C-u>VimFilerBufferDir -quit<CR>
    "現在開いているバッファをIDE風に開く
    nnoremap <silent> <Leader>fi :<C-u>VimFilerBufferDir -split -simple -winwidth=35 -no-quit<CR>
  endfunction

  "デフォルトのキーマッピングを変更
  augroup vimrc
    autocmd FileType vimfiler call s:vimfiler_my_settings()
  augroup END
  function! s:vimfiler_my_settings()
    nmap <buffer> q <Plug>(vimfiler_exit)
    nmap <buffer> Q <Plug>(vimfiler_hide)
  endfunction

  call s:bundle_untap()
endif " }}}

"------------------------------------
" NERDTree
"------------------------------------

if s:bundle_tap('nerdtree.vim') " {{{
  function! s:tapped_bundle.hooks.on_source(bundle)
      " 隠しファイルを表示
      let g:NERDTreeShowHidden=1
      " ツリーの幅
      let g:NERDTreeWinSize=26
      " カラースキーマを優先
      let g:NERDChristmasTree=0
      " open 後閉じる
      let g:NERDTreeQuitOnOpen=1
      " 表示しないファイル
      let g:NERDTreeIgnore=['\.DS_Store$', '\.clean$', '\.swp$', '\.bak$', '\~$']
      " ステータスライン
      let g:NERDTreeStatusline=' '
  endfunction

  " カーソルが外れているときは自動的にnerdtreeを隠す
  function! ExecuteNERDTree()
    "b:nerdstatus = 1 : NERDTree 表示中
    "b:nerdstatus = 2 : NERDTree 非表示中
    " key mappings
    if !exists('g:nerdstatus')
      execute 'NERDTree ./'
      let g:windowWidth = winwidth(winnr())
      let g:nerdtreebuf = bufnr('')
      let g:nerdstatus = 1
    elseif g:nerdstatus == 1
      execute 'wincmd t'
      execute 'vertical resize' 0
      execute 'wincmd p'
      let g:nerdstatus = 2
    elseif g:nerdstatus == 2
      execute 'wincmd t'
      execute 'vertical resize' g:windowWidth
      let g:nerdstatus = 1
    endif
  endfunction
  noremap <C-m> :<C-u>:call ExecuteNERDTree()<cr>

  call s:bundle_untap()
endif " }}}

"------------------------------------
" t_comment
"------------------------------------

let g:tcommentmaps=0
noremap <silent><C-_><c-_> :TComment<CR>
noremap <silent><C-_>c :TComment<CR>

"------------------------------------
" operator, NERD_Commenter コメントPlugin
"------------------------------------
"function! s:SID_PREFIX()
"  return matchstr(expand('<sfile>'), '<SNR>\d\+_')
"endfunction
"
"noremap [Operator] <Nop>
"map , [Operator]
"
"" デフォルトのマッピング定義を行わない
"let g:NERDCreateDefaultMappings = 0
" コメントした後に挿入するスペースの数
"let g:NERDSpaceDelims = 1
"
"nmap gA <Plug>NERDCommenterAppend
"nmap [Prefix]a <Plug>NERDCommenterAltDelims
"
"" NERDCommenter + operator-user
"function! s:setCommentOperator(key, name)
"  call operator#user#define(
"        \   'comment-' . a:name,
"        \   s:SID_PREFIX() . 'doCommentCommand',
"        \   'call ' . s:SID_PREFIX() . 'setCommentCommand("' . a:name . '")')
"  execute 'map' a:key '<Plug>(operator-comment-' . a:name . ')'
"endfunction
"
"function! s:setCommentCommand(command)
"  let s:comment_command = a:command
"endfunction
"
"function! s:doCommentCommand(motion_wiseness)
"  let v = operator#user#visual_command_from_wise_name(a:motion_wiseness)
"  execute 'normal! `[' . v . "`]\<Esc>"
"  call NERDComment(1, s:comment_command)
"endfunction
"
"call s:setCommentOperator('[Operator]c',       'norm')
"call s:setCommentOperator('[Operator]<Scace>', 'toggle')
"call s:setCommentOperator('[Operator]m',       'minimal')
"call s:setCommentOperator('[Operator]s',       'sexy')
"call s:setCommentOperator('[Operator]i',       'invert')
"call s:setCommentOperator('[Operator]y',       'yank')
"call s:setCommentOperator('[Operator]l',       'alignLeft')
"call s:setCommentOperator('[Operator]b',       'alignBoth')
"call s:setCommentOperator('[Operator]n',       'nested')
"call s:setCommentOperator('[Operator]u',       'uncomment')

if s:bundle_tap('matchit.vim') " {{{
  function! s:tapped_bundle.hooks.on_source(bundle)
  endfunction
  call s:bundle_untap()
endif " }}}

"------------------------------------
" surround.vim
"------------------------------------
"{{{
" s, ssで選択範囲を指定文字でくくる
nmap s <Plug>Ysurround
nmap ss <Plug>Yssurround
"}}}

"------------------------------------
" minibufexplorer
"------------------------------------
"let g:miniBufExplMapWindowNavVim=1 "hjklで移動
"let g:miniBufExplSplitBelow=0  " Put new window above
"let g:miniBufExplMapWindowNavArrows=1
"let g:miniBufExplMapCTabSwitchBufs=1
"let g:miniBufExplModSelTarget=1
"let g:miniBufExplSplitToEdge=1
"let g:miniBufExplMaxSize = 10
"
"":TmでMiniBufExplorerの表示トグル
"command! Mt :TMiniBufExplorer

"------------------------------------
" vim-less.vim
"------------------------------------
"nnoremap ,m :w <BAR> !lessc % > %:t:r.css<CR><space>

""------------------------------------
"" TwitVim.vim
""------------------------------------
"let twitvim_count = 40
"nnoremap ,tp :<C-u>PosttoTwitter<CR>
"nnoremap ,tf :<C-u>FriendsTwitter<CR><C-w>j
"nnoremap ,tu :<C-u>UserTwitter<CR><C-w>j
"nnoremap ,tr :<C-u>RepliesTwitter<CR><C-w>j
"nnoremap ,tn :<C-u>NextTwitter<CR>
"
"autocmd FileType twitvim call s:twitvim_my_settings()
"function! s:twitvim_my_settings()
"  set nowrap
"endfunction


"------------------------------------
" endwise.vim
"------------------------------------

"{{{
let g:endwise_no_mappings=1
"}}}

"------------------------------------
" mkd.vim
" Markdown-syntax
"------------------------------------
"{{{
autocmd BufRead,BufNewFile *.mkd setfiletype mkd
autocmd BufRead,BufNewFile *.md  setfiletype mkd
"}}}

"------------------------------------
" align
"------------------------------------
"{{{
let g:Align_xstrlen=3
"}}}

"------------------------------------
" open-browser.vim
"------------------------------------
"{{{
let g:netrw_nogx = 1 " disable netrw's gx mapping.
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)
"}}}

"------------------------------------
" browserrefresh.vim
"------------------------------------
"{{{
let g:RefreshRunningBrowserDefault = 'chrome'
let g:RefreshRunningBrowserReturnFocus = 0
"}}}

"------------------------------------
" browserrefresh.vim
"------------------------------------
""  2html.vim {{{
""  http://nanasi.jp/articles/vim/2html_vim.html
""  :TOhtml
""  html_number_line 1:行番号を付ける 0:付けない undefined:numberオプションに応じる
" let html_number_lines = 0
""  html_use_css 1:use CSS undefined:not use CSS
" let html_use_css = 1
""  html_no_pre 1:not use pre element undefine:use pre element
""  use_xhtml 1:use xhtml
" let use_xhtml = 1
" " }}}

"------------------------------------
" yanktmp.vim
"------------------------------------

" map <silent> sy :call YanktmpYank()<CR>
" map <silent> sp :call YanktmpPaste_p()<CR>
" map <silent> sP :call YanktmpPaste_P()<CR>

"------------------------------------
" gundo.vim
"------------------------------------

"{{{
nmap U :<C-u>GundoToggle<CR>
"}}}

"------------------------------------
" tagbar.vim
"------------------------------------
"{{{
set tags=~/.tags
nmap <F8> :TagbarToggle<CR>

let g:alpaca_update_tags_config = {
      \ '_' : '-R --sort=yes',
      \ 'js' : '--languages=+js',
      \ '-js' : '--languages=-js,JavaScript',
      \ 'vim' : '--languages=+Vim,vim',
      \ '-vim' : '--languages=-Vim,vim',
      \ '-style': '--languages=-css,sass,scss,js,JavaScript,html',
      \ 'scss' : '--languages=+scss --languages=-css,sass',
      \ 'sass' : '--languages=+sass --languages=-css,scss',
      \ 'css' : '--languages=+css',
      \ 'java' : '--languages=+java $JAVA_HOME/src',
      \ 'ruby': '--languages=+Ruby',
      \ 'coffee': '--languages=+coffee',
      \ '-coffee': '--languages=-coffee',
      \ 'bundle': '--languages=+Ruby --languages=-css,sass,scss,js,JavaScript,coffee',
      \ }

"aug AlpacaUpdateTags
"  au!
"  au FileWritePost,BufWritePost * AlpacaTagsUpdate -style
"  " bundleのオプションは自動で追加して実行します。
"  au FileWritePost,BufWritePost Gemfile AlpacaTagsUpdateBundle
"  au FileReadPost,BufEnter * AlpacaTagsSet
"aug END
"}}}

"------------------------------------
" taglist
"------------------------------------
" set tags=~/.tags
" let Tlist_Show_One_File = 1 "現在編集中のソースのタグしか表示しない
" let Tlist_Exit_OnlyWiindow = 1 "taglist が最後のウインドウなら vim を閉じる
" let Tlist_Use_Right_Window = 1
" let Tlist_WinWidth = 40
" let Tlist_File_Fold_Auto_Close = 1
" let Tlist_Process_File_Always = 1
" let Tlist_Enable_Fold_Column = 0
" let Tlist_GainFocus_On_ToggleOpen = 1
" let Tlist_Sort_Type = "name"
" map <silent> <leader>tl :TlistToggle<CR>
"nnoremap <leader>t :Tlist<CR>

"------------------------------------
" indentline.vim
" vim-indent-guides.vim
"------------------------------------

if s:bundle_tap('indentLine.vim') " {{{
  function! s:tapped_bundle.hooks.on_source(bundle)
    nnoremap <Space>i :<C-U>IndentLinesToggle<CR>
    let g:indentLine_color_term = 239
    " let g:indentLine_color_gui = '#A4E57E'
    " let g:indentLine_char = 'c'
    let g:indentLine_fileType=g:my.ft.program_files
    " let g:indentLine_noConcealCursor=
    " hi Conceal ctermfg=239 ctermbg=NONE
    " ¦┆│
  endfunction
  call s:bundle_untap()
endif " }}}

if s:bundle_tap('indent_guides.vim') " {{{
  function! s:tapped_bundle.hooks.on_source(bundle)
    let g:indent_guides_auto_colors=0
    let g:indent_guides_color_change_percent = 20
    let g:indent_guides_enable_on_vim_startup=1
    let g:indent_guides_guide_size=1
    let g:indent_guides_space_guides = 1
    let g:indent_guides_start_level = 2
    hi IndentGuidesOdd  ctermbg=235
    hi IndentGuidesEven ctermbg=233
    nnoremap <Space>i :<C-U>IndentGuidesToggle<CR>

    augroup MyAutoCmd
      au BufEnter * let g:indent_guides_guide_size=&tabstop
    augroup END
  endfunction
  call s:bundle_untap()
endif " }}}

" FuzzyFinder.vim "{{{
if s:bundle_tap('fuzzyfinder.vim') " {{{
  function! s:tapped_bundle.hooks.on_source(bundle)
    nnoremap <Space>f f
    nnoremap <Space>F F
    nnoremap f <Nop>
    nnoremap <silent> fb :<C-u>FufBuffer!<CR>
    nnoremap <silent> ff :<C-u>FufFile! <C-r>=expand('%:~:.')[:-1-len(expand('%:~:.:t'))]<CR><CR>
    nnoremap <silent> fm :<C-u>FufMruFile!<CR>
    nnoremap <silent> tb :<C-u>tabnew<CR>:tabmove<CR>:FufBuffer!<CR>
    nnoremap <silent> tf :<C-u>tabnew<CR>:tabmove<CR>:FufFile! <C-r>=expand('#:~:.')[:-1-len(expand('#:~:.:t'))]<CR><CR>
    nnoremap <silent> tm :<C-u>tabnew<CR>:tabmove<CR>:FufMruFile!<CR>
  endfunction
  call s:bundle_untap()
endif " }}}

"------------------------------------
" vim-textmanip
"------------------------------------

if s:bundle_tap('textmanip.vim') " {{{
  function! s:tapped_bundle.hooks.on_source(bundle)
    " 選択したテキストの移動
    vmap <C-j> <Plug>(Textmanip.move_selection_down)
    vmap <C-k> <Plug>(Textmanip.move_selection_up)
    vmap <C-h> <Plug>(Textmanip.move_selection_left)
    vmap <C-l> <Plug>(Textmanip.move_selection_right)
    " 行の複製
    vmap <D-d> <Plug>(Textmanip.duplicate_selection_v)
    nmap <D-d> <Plug>(Textmanip.duplicate_selection_n)
  endfunction
  call s:bundle_untap()
endif " }}}

"------------------------------------
" sass-compile
"------------------------------------
""{{{
"   let g:sass_compile_auto = 1
"   let g:sass_compile_cdloop = 5
"   let g:sass_compile_cssdir = ['css', 'stylesheet']
"   let g:sass_compile_file = ['scss', 'sass']
"   let g:sass_started_dirs = []
"   autocmd FileType less,sass  setlocal sw=2 sts=2 ts=2 et
"   au! BufWritePost * SassCompile
"}}}


"------------------------------------
" gitv.git
"------------------------------------

"{{{
autocmd FileType gitv call s:my_gitv_settings()
function! s:my_gitv_settings()
  setlocal iskeyword+=/,-,.
  nnoremap <silent><buffer> C :<C-u>Git checkout <C-r><C-w><CR>

  nnoremap <buffer> <Space>rb :<C-u>Git rebase <C-r>=GitvGetCurrentHash()<CR><Space>
  nnoremap <buffer> <Space>R :<C-u>Git revert <C-r>=GitvGetCurrentHash()<CR><CR>
  nnoremap <buffer> <Space>h :<C-u>Git cherry-pick <C-r>=GitvGetCurrentHash()<CR><CR>
  nnoremap <buffer> <Space>rh :<C-u>Git reset --hard <C-r>=GitvGetCurrentHash()<CR>

  nnoremap <silent><buffer> t :<C-u>windo call <SID>toggle_git_folding()<CR>1<C-w>w
endfunction

function! s:gitv_get_current_hash()
  return matchstr(getline('.'), '\[\zs.\{7\}\ze\]$')
endfunction

autocmd FileType git setlocal nofoldenable foldlevel=0
function! s:toggle_git_folding()
  if &filetype ==# 'git'
    setlocal foldenable!
  endif
endfunction
"}}}


"------------------------------------
" vim-gitgutter
"------------------------------------

nnoremap <silent> <leader>gg :<C-u>GitGutterToggle<CR>
nnoremap <silent> <leader>gh :<C-u>GitGutterLineHighlightsToggle<CR>


