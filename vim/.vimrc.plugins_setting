"------------------------------------
" vim-quickrun
"------------------------------------
let g:quickrun_config = {}
let g:quickrun_config._ = { 'runner' : 'vimproc' }
let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec', 'split': '' }
"let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec', 'cmdopt': 'bundle exec', 'exec': '%o %c %s' }
let g:quickrun_config['markdown'] = {
    \ 'command' : 'pandoc',
    \ 'exec': ['%c -s -f markdown -t html -o %s:p:r.html %s', 'w3m %s:p:r.html', 'sleep 1', 'rm %s:p:r.html'],
    \ 'outputter': 'browser',
    \ 'cmdopt': '-s',
    \ 'tempfile': '{tempname()}.md' }

augroup QuickrunRSpec
  autocmd!
  autocmd BufWinEnter,BufNewFile *_spec.rb set filetype=ruby.rspec
augroup END

"------------------------------------
" vim-proc
"------------------------------------

if has('mac')
  let g:vimproc_dll_path = $VIMRUNTIME . '/autoload/vimproc_mac.so'
elseif has('win32')
  let g:vimproc_dll_path = $HOME . '.vim/bundle/vimproc/autoload/vimproc_win32.dll'
elseif has('win64')
  let g:vimproc_dll_path = $HOME . '.vim/bundle/vimproc/autoload/vimproc_win64.dll'
endif

"------------------------------------
" minibufexplorer
"------------------------------------
let g:miniBufExplMapWindowNavVim=1 "hjklで移動
let g:miniBufExplSplitBelow=0  " Put new window above
let g:miniBufExplMapWindowNavArrows=1
let g:miniBufExplMapCTabSwitchBufs=1
let g:miniBufExplModSelTarget=1
let g:miniBufExplSplitToEdge=1
let g:miniBufExplMaxSize = 10

":TmでMiniBufExplorerの表示トグル
command! Mt :TMiniBufExplorer

"------------------------------------
" rails.vim
"------------------------------------
let g:rails_level = 4
let g:rails_devalut_database = 'mysql'

"------------------------------------
" html5.vim
" https://github.com/othree/html5.vim/blob/master/README.markdown
"------------------------------------
" Disable event-handler attributes support:
let g:html5_event_handler_attributes_complete = 0
" Disable RDFa attributes support:
let g:html5_rdfa_attributes_complete = 0
" Disable microdata attributes support:
let g:html5_microdata_attributes_complete = 0
" Disable WAI-ARIA attribute support:
let g:html5_aria_attributes_complete = 0

"------------------------------------
" vim-less.vim
"------------------------------------
nnoremap ,m :w <BAR> !lessc % > %:t:r.css<CR><space>

"------------------------------------
" TwitVim.vim
"------------------------------------
let twitvim_count = 40
nnoremap ,tp :<C-u>PosttoTwitter<CR>
nnoremap ,tf :<C-u>FriendsTwitter<CR><C-w>j
nnoremap ,tu :<C-u>UserTwitter<CR><C-w>j
nnoremap ,tr :<C-u>RepliesTwitter<CR><C-w>j
nnoremap ,tn :<C-u>NextTwitter<CR>

autocmd FileType twitvim call s:twitvim_my_settings()
function! s:twitvim_my_settings()
  set nowrap
endfunction

"------------------------------------
" unite.vim
"------------------------------------
if $SUDO_USER != ''
else
" 入力モードで開始する
let g:unite_enable_start_insert=1
" インサート／ノーマルどちらからでも呼び出せるようにキーマップ
nnoremap <silent> <C-f> :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
inoremap <silent> <C-f> <ESC>:<C-u>UniteWithBufferDir -buffer-name=files file<CR>
nnoremap <silent> <C-b> :<C-u>Unite buffer file_mru<CR>
inoremap <silent> <C-b> <ESC>:<C-u>Unite buffer file_mru<CR>

" For ack.
if executable('ack-grep')
  let g:unite_source_grep_command = 'ack-grep'
  let g:unite_source_grep_default_opts = '--no-heading --no-color -a'
  let g:unite_source_grep_recursive_opt = ''
endif

"data_directory はramdiskを指定
if has('win32')
elseif  has('macunix')
  let g:unite_data_directory = $HOME . '/.vim/.unite'
else
  let g:unite_data_directory = $HOME . '/.unite'
endif

"file_mruの表示フォーマットを指定。空にすると表示スピードが高速化される
let g:unite_source_file_mru_filename_format = ''

"bookmarkだけホームディレクトリに保存
let g:unite_source_bookmark_directory = $HOME . '/.unite/bookmark'

" バッファ一覧
nnoremap <silent> ,ub :<C-u>Unite buffer<CR>
" ファイル一覧
nnoremap <silent> ,uf :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
" レジスタ一覧
nnoremap <silent> ,ur :<C-u>Unite -buffer-name=register register<CR>
" 最近使用したファイル一覧
nnoremap <silent> ,um :<C-u>Unite file_mru<CR>
" 常用セット
nnoremap <silent> ,uu :<C-u>Unite buffer file_mru<CR>
" 全部乗せ
nnoremap <silent> ,ua :<C-u>UniteWithBufferDir -buffer-name=files buffer file_mru bookmark file<CR>
"ブックマーク一覧
nnoremap <silent> ,uc :<C-u>Unite bookmark<CR>
"ブックマークに追加
nnoremap <silent> ,ua :<C-u>UniteBookmarkAdd<CR>

" ウィンドウを分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
au FileType unite inoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
" ウィンドウを縦に分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
au FileType unite inoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
" ESCキーを2回押すと終了する
au FileType unite nnoremap <silent> <buffer> <ESC><ESC> q
au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>q

" unite.vim上でのキーマッピング
autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
  " 単語単位からパス単位で削除するように変更
  imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
  " ESCキーを2回押すと終了する
  nmap <silent><buffer> <ESC><ESC> q
  imap <silent><buffer> <ESC><ESC> <ESC>q
endfunction


" diff用Uniteのaction
let diff_action = {
      \   'description' : 'diff',
      \   'is_selectable' : 1,
      \ }

function! diff_action.func(candidates)
  if len(a:candidates) == 1
    " カレントバッファとdiffを取る
    execute 'vert diffsplit ' . a:candidates[0].action__path
  elseif len(a:candidates) == 2
    " 選択されたファイルとdiffを取る
    execute 'tabnew ' . a:candidates[0].action__path
    execute 'vert diffsplit ' . a:candidates[1].action__path
  else
    " 3-way以上は非対応
    echo 'too many candidates!'
  endif
endfunction

call unite#custom_action('file', 'diff', diff_action)

unlet diff_action

endif

"-----------------------------------
" vimfiler.vim
"------------------------------------
"vimfiler {{{

"data_directory はramdiskを指定
if has('win32')
elseif  has('macunix')
  let g:vimfiler_data_directory = $HOME . '/.vim/.vimfiler'
else
  let g:vimfiler_data_directory = $HOME . '/.vimfiler'
endif

"vimデフォルトのエクスプローラをvimfilerで置き換える
let g:vimfiler_as_default_explorer = 1
"セーフモードを無効にした状態で起動する
let g:vimfiler_safe_mode_by_default = 0
"現在開いているバッファのディレクトリを開く
nnoremap <silent> <Leader>fe :<C-u>VimFilerBufferDir -quit<CR>
"現在開いているバッファをIDE風に開く
nnoremap <silent> <Leader>fi :<C-u>VimFilerBufferDir -split -simple -winwidth=35 -no-quit<CR>

"デフォルトのキーマッピングを変更
augroup vimrc
  autocmd FileType vimfiler call s:vimfiler_my_settings()
augroup END
function! s:vimfiler_my_settings()
  nmap <buffer> q <Plug>(vimfiler_exit)
  nmap <buffer> Q <Plug>(vimfiler_hide)
endfunction

"}}}

"-----------------------------------
" grep.vim
"------------------------------------

" :Gb <args> でGrepBufferする
command! -nargs=1 Gb :GrepBuffer <args>
" カーソル下の単語をGrepBufferする
nnoremap <C-g><C-b> :<C-u>GrepBuffer<Space><C-r><C-w><Enter>

"------------------------------------
" operator, NERD_Commenter コメントPlugin
"------------------------------------
function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_')
endfunction

noremap [Operator] <Nop>
map , [Operator]

" デフォルトのマッピング定義を行わない
let g:NERDCreateDefaultMappings = 0
" コメントした後に挿入するスペースの数
let g:NERDSpaceDelims = 1

nmap gA <Plug>NERDCommenterAppend
nmap [Prefix]a <Plug>NERDCommenterAltDelims

" NERDCommenter + operator-user
function! s:setCommentOperator(key, name)
  call operator#user#define(
        \   'comment-' . a:name,
        \   s:SID_PREFIX() . 'doCommentCommand',
        \   'call ' . s:SID_PREFIX() . 'setCommentCommand("' . a:name . '")')
  execute 'map' a:key '<Plug>(operator-comment-' . a:name . ')'
endfunction

function! s:setCommentCommand(command)
  let s:comment_command = a:command
endfunction

function! s:doCommentCommand(motion_wiseness)
  let v = operator#user#visual_command_from_wise_name(a:motion_wiseness)
  execute 'normal! `[' . v . "`]\<Esc>"
  call NERDComment(1, s:comment_command)
endfunction

call s:setCommentOperator('[Operator]c',       'norm')
call s:setCommentOperator('[Operator]<Scace>', 'toggle')
call s:setCommentOperator('[Operator]m',       'minimal')
call s:setCommentOperator('[Operator]s',       'sexy')
call s:setCommentOperator('[Operator]i',       'invert')
call s:setCommentOperator('[Operator]y',       'yank')
call s:setCommentOperator('[Operator]l',       'alignLeft')
call s:setCommentOperator('[Operator]b',       'alignBoth')
call s:setCommentOperator('[Operator]n',       'nested')
call s:setCommentOperator('[Operator]u',       'uncomment')

"------------------------------------
" 補間 neocomplcache
"------------------------------------

if $SUDO_USER != ''
else

" Disable AutoComplPop. Comment out this line if AutoComplPop is not installed.
let g:acp_enableAtStartup = 0
" Launches neocomplcache automatically on vim startup.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Use camel case completion.
let g:neocomplcache_enable_camel_case_completion = 1
" Use underscore completion.
let g:neocomplcache_enable_underbar_completion = 1
" Sets minimum char length of syntax keyword.
let g:neocomplcache_min_syntax_length = 3
" buffer file name pattern that locks neocomplcache. e.g. ku.vim or fuzzyfinder
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

" Define file-type dependent dictionaries.
let g:neocomplcache_dictionary_filetype_lists = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
    \ }

" Define keyword, for minor languages
if !exists('g:neocomplcache_keyword_patterns')
  let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
imap <C-k>     <Plug>(neocomplcache_snippets_expand)
smap <C-k>     <Plug>(neocomplcache_snippets_expand)
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()

" SuperTab like snippets behavior.
imap <expr><TAB> neocomplcache#sources#snippets_complete#expandable() ? "\<Plug>(neocomplcache_snippets_expand)" : pumvisible() ? "\<C-n>" : "\<TAB>"

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
inoremap <expr><C-e>  neocomplcache#cancel_popup()

" AutoComplPop like behavior.
"let g:neocomplcache_enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplcache_enable_auto_select = 1
"let g:neocomplcache_disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<TAB>"
"inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"

" Enable omni completion. Not required if they are already set elsewhere in .vimrc
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion, which require computational power and may stall the vim.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
"autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'

endif

autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS

if !exists('g:neocomplcache_omni_functions')
    let g:neocomplcache_omni_functions = {}
endif

"let g:neocomplcache_omni_functions.javascript = ['nodejscomplete#CompleteJS', 'javascriptcomplete#CompleteJS']
let g:jscomplete_use = ['dom', 'moz']


"------------------------------------
" snippets
"------------------------------------

let g:neosnippet#snippets_directory='~/.vim/snipmate-snippets/snippets'

" let g:snippets_dir = $HOME.'/.vim/snippets'

imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
  \ 'default' : '',
  \ 'ruby' : $HOME.'/.vim/snippets/ruby.snippets',
  \ 'erb' : $HOME.'/.vim/snippets/erb.snippets',
  \ 'html' : $HOME.'/.vim/snippets/html.snippets',
  \ 'css' : $HOME.'/.vim/snippets/css.snippets',
  \ 'javascript' : $HOME.'/.vim/snippets/javascript.snippets'
  \ }

" snipMate再読み込み。xxx.snippetを開いているときに:call SnipMateReload()すればＯＫ
function! SnipMateReload()
    if &ft == 'snippet'
        let ft = substitute(expand('%'), '.snippets', '', '')
        if has_key(g:did_ft, ft)
            unlet g:did_ft[ft]
        endif
        silent! call GetSnippets(g:snippets_dir, ft)
    endif
endfunction

"------------------------------------
" surround.vim
"------------------------------------
" s, ssで選択範囲を指定文字でくくる
nmap s <Plug>Ysurround
nmap ss <Plug>Yssurround

"------------------------------------
" mkd.vim
" Markdown-syntax
"------------------------------------
autocmd BufRead,BufNewFile *.mkd setfiletype mkd
autocmd BufRead,BufNewFile *.md  setfiletype mkd

"------------------------------------
" syntastic
"------------------------------------
let g:syntastic_check_on_open=0 "ファイルを開いたときはチェックしない
let g:syntastic_check_on_save=1 "保存時にはチェック
let g:syntastic_auto_loc_list=1 "エラーがあったら自動でロケーションリストを開く
let g:syntastic_loc_list_height=6 "エラー表示ウィンドウの高さ
set statusline+=%#warningmsg# "エラーメッセージの書式
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
compiler ruby
let g:syntastic_mode_map = {
  \ 'mode': 'passive',
  \ 'active_filetypes': ['ruby', 'javascript', 'html', 'css'],
  \ 'passive_filetypes': [] }
"エラー表示マークを変更
let g:syntastic_enable_signs=1
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'

"------------------------------------
" taglist
"------------------------------------
set tags=tags
let Tlist_Show_One_File = 1 "現在編集中のソースのタグしか表示しない
let Tlist_Exit_OnlyWiindow = 1 "taglist が最後のウインドウなら vim を閉じる
let Tlist_Use_Right_Window = 1
let Tlist_WinWidth = 40
let Tlist_File_Fold_Auto_Close = 1
let Tlist_Process_File_Always = 1
let Tlist_Enable_Fold_Column = 0
let Tlist_GainFocus_On_ToggleOpen = 1
let Tlist_Sort_Type = "name"
map <silent> <leader>tl :TlistToggle<CR>

"------------------------------------
" align.vim
"------------------------------------
let g:Align_xstrlen=3

"------------------------------------
" open-browser.vim
"------------------------------------
let g:netrw_nogx = 1 " disable netrw's gx mapping.
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)

"------------------------------------
" browserrefresh.vim
"------------------------------------
let g:RefreshRunningBrowserDefault = 'chrome'
let g:RefreshRunningBrowserReturnFocus = 0


"------------------------------------
" browserrefresh.vim
"------------------------------------
""  2html.vim {{{
""  http://nanasi.jp/articles/vim/2html_vim.html
""  :TOhtml
""  html_number_line 1:行番号を付ける 0:付けない undefined:numberオプションに応じる
" let html_number_lines = 0
""  html_use_css 1:use CSS undefined:not use CSS
" let html_use_css = 1
""  html_no_pre 1:not use pre element undefine:use pre element
""  use_xhtml 1:use xhtml
" let use_xhtml = 1
" " }}}

"------------------------------------
" yanktmp.vim
"------------------------------------

" map <silent> sy :call YanktmpYank()<CR>
" map <silent> sp :call YanktmpPaste_p()<CR>
" map <silent> sP :call YanktmpPaste_P()<CR>

"------------------------------------
" vim-indent-guides.vim
"------------------------------------

let g:indent_guides_auto_colors = 0
let g:indent_guides_start_level = 1
let g:indent_guides_guide_size = 1

augroup indentguides
    autocmd!
    autocmd VimEnter,Colorscheme * :hi IndentGuidesEven ctermbg=236
    autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd ctermbg=235
augroup END
let g:indent_guides_enable_on_vim_startup = 1



