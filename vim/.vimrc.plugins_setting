
function! s:bundle_tap(bundle) " {{{
  let s:tapped_bundle = neobundle#get(a:bundle)
  return neobundle#is_installed(a:bundle)
endfunction " }}}

function! s:bundle_config(config) " {{{
  if exists("s:tapped_bundle") && s:tapped_bundle != {}
    call neobundle#config(s:tapped_bundle.name, a:config)
  endif
endfunction " }}}

function! s:bundle_untap() " {{{
  let s:tapped_bundle = {}
endfunction " }}}

"------------------------------------
" vim-singleton
"------------------------------------

"call singleton#enable()

"------------------------------------
" vim-quickrun
"------------------------------------
let g:quickrun_config = {}
let g:quickrun_config._ = { 'runner' : 'vimproc' }
let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec', 'split': '' }
"let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec', 'cmdopt': 'bundle exec', 'exec': '%o %c %s' }
let g:quickrun_config['markdown'] = {
    \ 'command' : 'pandoc',
    \ 'exec': ['%c -s -f markdown -t html -o %s:p:r.html %s', 'w3m %s:p:r.html', 'sleep 1', 'rm %s:p:r.html'],
    \ 'outputter': 'browser',
    \ 'cmdopt': '-s',
    \ 'tempfile': '{tempname()}.md' }

augroup QuickrunRSpec
  autocmd!
  autocmd BufWinEnter,BufNewFile *_spec.rb set filetype=ruby.rspec
augroup END

"------------------------------------
" vim-proc
"------------------------------------

if has('mac')
  let g:vimproc_dll_path = $VIMRUNTIME . '/autoload/vimproc_mac.so'
elseif has('win32')
  let g:vimproc_dll_path = $HOME . '.vim/bundle/vimproc/autoload/vimproc_win32.dll'
elseif has('win64')
  let g:vimproc_dll_path = $HOME . '.vim/bundle/vimproc/autoload/vimproc_win64.dll'
endif

"------------------------------------
" minibufexplorer
"------------------------------------
"let g:miniBufExplMapWindowNavVim=1 "hjklで移動
"let g:miniBufExplSplitBelow=0  " Put new window above
"let g:miniBufExplMapWindowNavArrows=1
"let g:miniBufExplMapCTabSwitchBufs=1
"let g:miniBufExplModSelTarget=1
"let g:miniBufExplSplitToEdge=1
"let g:miniBufExplMaxSize = 10
"
"":TmでMiniBufExplorerの表示トグル
"command! Mt :TMiniBufExplorer

"------------------------------------
" vim-rails
"------------------------------------

""{{{
"有効化
"let g:rails_devalut_database = 'mysql'
let g:rails_default_file='config/database.yml'
let g:rails_level = 4
let g:rails_mappings=1
let g:rails_modelines=0
" let g:rails_some_option = 1
" let g:rails_statusline = 1
" let g:rails_subversion=0
" let g:rails_syntax = 1
" let g:rails_url='http://localhost:3000'
" let g:rails_ctags_arguments='--languages=-javascript'
" let g:rails_ctags_arguments = ''
function! SetUpRailsSetting()
  nnoremap <buffer><Space>r :R<CR>
  nnoremap <buffer><Space>a :A<CR>
  nnoremap <buffer><Space>m :Rmodel<Space>
  nnoremap <buffer><Space>c :Rcontroller<Space>
  nnoremap <buffer><Space>v :Rview<Space>
  nnoremap <buffer><Space>p :Rpreview<CR>
endfunction

aug MyAutoCmd
  au User Rails call SetUpRailsSetting()
aug END

aug RailsDictSetting
  au!
aug END
"}}}

"------------------------------------
" html5.vim
" https://github.com/othree/html5.vim/blob/master/README.markdown
"------------------------------------
" Disable event-handler attributes support:
let g:html5_event_handler_attributes_complete = 0
" Disable RDFa attributes support:
let g:html5_rdfa_attributes_complete = 0
" Disable microdata attributes support:
let g:html5_microdata_attributes_complete = 0
" Disable WAI-ARIA attribute support:
let g:html5_aria_attributes_complete = 0

"------------------------------------
" vim-less.vim
"------------------------------------
nnoremap ,m :w <BAR> !lessc % > %:t:r.css<CR><space>

""------------------------------------
"" TwitVim.vim
""------------------------------------
"let twitvim_count = 40
"nnoremap ,tp :<C-u>PosttoTwitter<CR>
"nnoremap ,tf :<C-u>FriendsTwitter<CR><C-w>j
"nnoremap ,tu :<C-u>UserTwitter<CR><C-w>j
"nnoremap ,tr :<C-u>RepliesTwitter<CR><C-w>j
"nnoremap ,tn :<C-u>NextTwitter<CR>
"
"autocmd FileType twitvim call s:twitvim_my_settings()
"function! s:twitvim_my_settings()
"  set nowrap
"endfunction

"------------------------------------
" unite.vim
"------------------------------------
if s:bundle_tap('unite.vim') " {{{
  call s:bundle_config({
        \   'autoload' : {
        \     'commands' : [
        \       {
        \         'name' : 'Unite',
        \         'complete' : 'customlist,unite#complete_source'
        \       },
        \       'UniteWithCursorWord',
        \       'UniteWithInput'
        \     ]
        \   }
        \ })

  function! s:tapped_bundle.hooks.on_source(bundle)
    aug MyUniteCmd
      autocmd!
      autocmd FileType unite call <SID>unite_my_settings()
    aug END

    " settings
    " 入力モードで開始する
    hi UniteCursorLine ctermbg=236   cterm=none
    let g:unite_cursor_line_highlight='UniteCursorLine'
    let g:unite_data_directory=g:my.dir.unite
    let g:unite_enable_split_vertically=1
    let g:unite_update_time=50
    let g:unite_enable_start_insert=1
    let g:unite_source_directory_mru_limit = 200
    let g:unite_source_directory_mru_time_format="(%m-%d %H:%M) "
    let g:unite_winheight=15
    let g:unite_source_file_mru_time_format="(%m-%d %H:%M) "
    let g:unite_source_file_mru_filename_format=":~:."
    let g:unite_source_file_mru_limit = 300
    let g:unite_winheight = 20
    let g:unite_marked_icon = "✓"
    let g:unite_force_overwrite_statusline=1
    let g:unite_source_history_yank_enable = 0
    let s:unite_kuso_hooks = {}
    "bookmarkだけホームディレクトリに保存
    "let g:unite_source_bookmark_directory = $HOME . '/.unite/bookmark'
    let s:unite_kuso_hooks = {}

    function! s:unite_my_settings()
      " インサート／ノーマルどちらからでも呼び出せるようにキーマップ
      nnoremap <silent> <C-f> :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
      inoremap <silent> <C-f> <ESC>:<C-u>UniteWithBufferDir -buffer-name=files file<CR>
      nnoremap <silent> <C-b> :<C-u>Unite buffer file_mru<CR>
      inoremap <silent> <C-b> <ESC>:<C-u>Unite buffer file_mru<CR>
      " 単語単位からパス単位で削除するように変更
      imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
      " ESCキーを2回押すと終了する
      nmap <silent><buffer> <ESC><ESC> q
      imap <silent><buffer> <ESC><ESC> <ESC>q
      " Ctrl-cキーを押すと終了する
      nmap <silent><buffer> <C-c> q
      imap <silent><buffer> <C-c> <C-c>q

      " バッファ一覧
      nnoremap <silent> ,ub :<C-u>Unite buffer<CR>
      " ファイル一覧
      nnoremap <silent> ,uf :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
      " レジスタ一覧
      nnoremap <silent> ,ur :<C-u>Unite -buffer-name=register register<CR>
      " 最近使用したファイル一覧
      nnoremap <silent> ,um :<C-u>Unite file_mru<CR>
      " 常用セット
      nnoremap <silent> ,uu :<C-u>Unite buffer file_mru<CR>
      " 全部乗せ
      nnoremap <silent> ,ua :<C-u>UniteWithBufferDir -buffer-name=files buffer file_mru bookmark file<CR>
      "ブックマーク一覧
      nnoremap <silent> ,uc :<C-u>Unite bookmark<CR>
      "ブックマークに追加
      nnoremap <silent> ,ua :<C-u>UniteBookmarkAdd<CR>

      setl nolist
      setl cursorline
      highlight link uniteMarkedLine Identifier
      highlight link uniteCandidateInputKeyword Statement

      " inoremap <silent><buffer><C-J> <Plug>(unite_loop_cursor_down)
      " inoremap <silent><buffer><C-K> <Plug>(unite_loop_cursor_up)
      nmap     <silent><buffer>f <Plug>(unite_toggle_mark_current_candidate)
      xmap     <silent><buffer>f <Plug>(unite_toggle_mark_selected_candidates)
      nmap     <silent><buffer><C-H> <Plug>(unite_toggle_transpose_window)
      nmap     <silent><buffer>p <Plug>(unite_toggle_auto_preview)
      nnoremap <silent><buffer><expr>S unite#do_action('split')
      nnoremap <silent><buffer><expr>V unite#do_action('vsplit')
      nnoremap <silent><buffer><expr>,, unite#do_action('vimfiler')
      nnoremap <silent><buffer>C gg0wC
      nnoremap <expr><buffer>re unite#do_action('replace')

      "" ウィンドウを分割して開く
      "au FileType unite nnoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
      "au FileType unite inoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
      "" ウィンドウを縦に分割して開く
      "au FileType unite nnoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
      "au FileType unite inoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
      "" ESCキーを2回押すと終了する
      "au FileType unite nnoremap <silent> <buffer> <ESC><ESC> q
      "au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>q

      " hook
      let unite = unite#get_current_unite()
      let buffer_name = unite.buffer_name != '' ? unite.buffer_name : '_'

      " バッファ名に基づいたフックを実行
      if has_key( s:unite_kuso_hooks, buffer_name )
        call s:unite_kuso_hooks[buffer_name]()
      endif

    endfunction

    function! s:unite_kuso_hooks.file_mru()
      syntax match uniteSource__FileMru_Dir /.*\// containedin=uniteSource__FileMru contains=uniteSource__FileMru_Time,uniteCandidateInputKeyword nextgroup=uniteSource__FileMru_Dir

      highlight link uniteSource__FileMru_Dir Directory
      highlight link uniteSource__FileMru_Time Comment
    endfunction
    function! s:unite_kuso_hooks.file()
      inoremap <buffer><Tab> <CR>
      syntax match uniteFileDirectory '.*\/'
      highlight link uniteFileDirectory Directory
    endfunction
    function! s:unite_kuso_hooks.versions_log()
      nnoremap <silent><buffer><expr>c unite#do_action('changeset')
      nnoremap <silent><buffer><expr>cp unite#do_action('changeset_prev')
      nnoremap <silent><buffer><expr>d unite#do_action('diff')
      nnoremap <silent><buffer><expr>diff_prev unite#do_action('diff_prev')
      nnoremap <silent><buffer><expr>r unite#do_action('yank_revision')
      nnoremap <silent><buffer><expr>rv unite#do_action('revert')
      nnoremap <silent><buffer><expr>rsh unite#do_action('reset_hard')
      nnoremap <silent><buffer><expr>rss unite#do_action('reset_soft')
    endfunction

  endfunction

  " For ack.
  if executable('ag')
    " Use ag in unite grep source.
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts =
          \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
          \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_max_candidates = 200
  elseif executable('ack-grep')
    " For ack.
    let g:unite_source_grep_command = 'ack-grep'
    let g:unite_source_grep_default_opts = '--no-heading --no-color -a'
    let g:unite_source_grep_recursive_opt = ''
  endif

  "------------------------------------
  " unite-reek, unite-rails_best_practices
  "------------------------------------

  nnoremap <silent> <C-H><C-R> :<C-u>Unite -no-quit reek<CR>
  nnoremap <silent> <C-H><C-R><C-R> :<C-u>Unite -no-quit rails_best_practices<CR>

  call s:bundle_untap()
endif " }}}

"------------------------------------
" unite-rails.vim
"------------------------------------
if s:bundle_tap('unite-rails.vim') " {{{
"  call s:bundle_config({
"        \ 'depends' : 'Shougo/unite.vim',
"        \ 'autoload' : {
"        \   'unite_sources' : [
"        \     'rails/bundle', 'rails/bundled_gem', 'rails/config',
"        \     'rails/controller', 'rails/db', 'rails/destroy', 'rails/features',
"        \     'rails/gem', 'rails/gemfile', 'rails/generate', 'rails/git', 'rails/helper',
"        \     'rails/heroku', 'rails/initializer', 'rails/javascript', 'rails/lib', 'rails/log',
"        \     'rails/mailer', 'rails/model', 'rails/rake', 'rails/route', 'rails/schema', 'rails/spec',
"        \     'rails/stylesheet', 'rails/view'
"        \   ]
"        \ }}

  function! s:tapped_bundle.hooks.on_source(bundle)
    aug MyUniteCmd
      autocmd!
      autocmd FileType unite call <SID>unite_rails_setting()
    aug END

    " let g:rails_ctags_arguments = ''
    " let g:rails_ctags_arguments='--languages=-javascript'
    " let g:rails_some_option = 1
    " let g:rails_statusline = 1
    " let g:rails_subversion=0
    let g:dbext_default_SQLITE_bin = 'mysql2'
    let g:rails_default_file='config/database.yml'
    let g:rails_gnu_screen=1
    let g:rails_level = 4
    let g:rails_mappings=1
    let g:rails_modelines=0
    let g:rails_syntax = 1
    let g:rails_url='http://localhost:3000'
  endfunction

  "noremap :rc :<C-u>Unite rails/controller<CR>
  "noremap :rm :<C-u>Unite rails/model<CR>
  "noremap :rv :<C-u>Unite rails/view<CR>
  "noremap :rh :<C-u>Unite rails/helper<CR>

  function! UniteRailsSetting()
    nnoremap <buffer><C-H><C-H><C-H>  :<C-U>Unite rails/view<CR>
    nnoremap <buffer><C-H><C-H>       :<C-U>Unite rails/model<CR>
    nnoremap <buffer><C-H>            :<C-U>Unite rails/controller<CR>

    nnoremap <buffer><C-H>c           :<C-U>Unite rails/config<CR>
    nnoremap <buffer><C-H>s           :<C-U>Unite rails/spec<CR>
    nnoremap <buffer><C-H>m           :<C-U>Unite rails/db -input=migrate<CR>
    nnoremap <buffer><C-H>l           :<C-U>Unite rails/lib<CR>
    nnoremap <buffer><expr><C-H>g     ':e '.b:rails_root.'/Gemfile<CR>'
    nnoremap <buffer><expr><C-H>r     ':e '.b:rails_root.'/config/routes.rb<CR>'
    nnoremap <buffer><expr><C-H>se    ':e '.b:rails_root.'/db/seeds.rb<CR>'
    nnoremap <buffer><C-H>ra          :<C-U>Unite rails/rake<CR>
    nnoremap <buffer><C-H>h           :<C-U>Unite rails/heroku<CR>
  endfunction
  aug MyAutoCmd
    au User Rails call UniteRailsSetting()
  aug END

  function! s:unite_rails_setting()
    call s:do_rails_autocmd()
    call s:set_up_rails_setting()
    nnoremap <Space>r :R<CR>
    nnoremap <Space>a :A<CR>
    nnoremap <buffer>[plug]            :<C-U>UniteGit app/models<CR>
    nnoremap <buffer>[plug]<C-H>       :<C-U>UniteGit app/controllers<CR>
    nnoremap <buffer>[plug]<C-H><C-H>  :<C-U>UniteGit app/views<CR>
    nnoremap <buffer>[plug]c           :<C-U>UniteGit config<CR>
    nnoremap <buffer>[plug]j           :<C-U>UniteGit app/assets/javascripts<CR>
    nnoremap <buffer>[plug]a           :<C-U>UniteGit app/assets/stylesheets<CR>
    nnoremap <buffer>[plug]s           :<C-U>UniteGit spec<CR>
    nnoremap <buffer>[plug]d           :<C-U>UniteGit db<CR>
    nnoremap <buffer>[plug]i           :<C-U>UniteGit db/migrate<CR>
    nnoremap <buffer>[plug]f           :<C-U>UniteGit db/fixtures<CR>
    nnoremap <buffer>[plug]m           :<C-U>UniteGit app/mailers<CR>
    nnoremap <buffer>[plug]l           :<C-U>UniteGit lib<CR>
    nnoremap <buffer>[plug]p           :<C-U>UniteGit public<CR>
    nnoremap <buffer>[plug]g           :<C-U>UniteGit Gemfile<CR>
    nnoremap <buffer>[plug]r           :<C-U>UniteGit config/routes.rb<CR>
    " nnoremap <buffer>[plug]h           :<C-U>UniteGit rails/heroku<CR>
    nnoremap <buffer>[plug]h           :<C-U>UniteGit app/helpers<CR>
    nnoremap <buffer><silent>,cr  :<C-U>RSpecCurrent<CR>
    nnoremap <buffer><silent>,nr :<C-U>RSpecNearest<CR>
    nnoremap <buffer><silent>,lr :<C-U>RSpecRetry<CR>
    nnoremap <buffer><silent>,ar :<C-U>RSpecAll<CR>
  endfunction
  function! s:do_rails_autocmd()
    if !exists("b:rails_root")
      return
    endif

    let buf = rails#buffer()
    let type = "-" . buf.type_name()
    let path = '/' . buf.name()
    if path =~ '[ !#$%\,]'
      let path = ''
    endif

    if type != '-'
      execute "silent doautocmd User Rails" . s:gsub(type, '-', '.')
    endif

    if path != ''
      execute "silent doautocmd User Rails" . path
    endif
  endfunction
  function! s:set_up_rails_setting()
    let buf = rails#buffer()
    let type_name = buf.calculate_file_type()
    let dict_name = "rails." . type_name
    set dict+=~/.vim/dict/ruby.rails.dict
    for s:syntax in split(glob($HOME.'/.vim/syntax/ruby.rails.*.vim'))
      execute 'source ' . s:syntax
    endfor
    execute 'nnoremap <buffer><Space><Space>d  :<C-U>Edit ~/.vim/dict/' . dict_name .'.dict<CR>'
    execute 'set dict+=~/.vim/dict/' . dict_name . '.dict'
  endfunction

  call s:bundle_untap()
endif " }}}


"-----------------------------------
" vimfiler.vim
"------------------------------------

"{{{
"data_directory はramdiskを指定
if has('win32')
elseif  has('macunix')
  let g:vimfiler_data_directory = $HOME . '/.vim/.vimfiler'
else
  let g:vimfiler_data_directory = $HOME . '/.vimfiler'
endif

"vimデフォルトのエクスプローラをvimfilerで置き換える
let g:vimfiler_as_default_explorer = 1
"セーフモードを無効にした状態で起動する
let g:vimfiler_safe_mode_by_default = 0
"現在開いているバッファのディレクトリを開く
nnoremap <silent> <Leader>fe :<C-u>VimFilerBufferDir -quit<CR>
"現在開いているバッファをIDE風に開く
nnoremap <silent> <Leader>fi :<C-u>VimFilerBufferDir -split -simple -winwidth=35 -no-quit<CR>

"デフォルトのキーマッピングを変更
augroup vimrc
  autocmd FileType vimfiler call s:vimfiler_my_settings()
augroup END
function! s:vimfiler_my_settings()
  nmap <buffer> q <Plug>(vimfiler_exit)
  nmap <buffer> Q <Plug>(vimfiler_hide)
endfunction

"}}}

"------------------------------------
" NERDTree
"------------------------------------

"{{{
" 隠しファイルを表示
let g:NERDTreeShowHidden=1
" ツリーの幅
let g:NERDTreeWinSize=26
" カラースキーマを優先
let g:NERDChristmasTree=0
" open 後閉じる
let g:NERDTreeQuitOnOpen=1
" 表示しないファイル
let g:NERDTreeIgnore=['\.DS_Store$', '\.clean$', '\.swp$', '\.bak$', '\~$']
" ステータスライン
let g:NERDTreeStatusline=' '

" カーソルが外れているときは自動的にnerdtreeを隠す
function! ExecuteNERDTree()
  "b:nerdstatus = 1 : NERDTree 表示中
  "b:nerdstatus = 2 : NERDTree 非表示中
  " key mappings
  if !exists('g:nerdstatus')
    execute 'NERDTree ./'
    let g:windowWidth = winwidth(winnr())
    let g:nerdtreebuf = bufnr('')
    let g:nerdstatus = 1
  elseif g:nerdstatus == 1
    execute 'wincmd t'
    execute 'vertical resize' 0
    execute 'wincmd p'
    let g:nerdstatus = 2
  elseif g:nerdstatus == 2
    execute 'wincmd t'
    execute 'vertical resize' g:windowWidth
    let g:nerdstatus = 1
  endif
endfunction
noremap <C-m> :<C-u>:call ExecuteNERDTree()<cr>

"}}}

"------------------------------------
" t_comment
"------------------------------------

let g:tcommentmaps=0
noremap <silent><C-_><c-_> :TComment<CR>
noremap <silent><C-_>c :TComment<CR>

"------------------------------------
" operator, NERD_Commenter コメントPlugin
"------------------------------------
"function! s:SID_PREFIX()
"  return matchstr(expand('<sfile>'), '<SNR>\d\+_')
"endfunction
"
"noremap [Operator] <Nop>
"map , [Operator]
"
"" デフォルトのマッピング定義を行わない
"let g:NERDCreateDefaultMappings = 0
" コメントした後に挿入するスペースの数
"let g:NERDSpaceDelims = 1
"
"nmap gA <Plug>NERDCommenterAppend
"nmap [Prefix]a <Plug>NERDCommenterAltDelims
"
"" NERDCommenter + operator-user
"function! s:setCommentOperator(key, name)
"  call operator#user#define(
"        \   'comment-' . a:name,
"        \   s:SID_PREFIX() . 'doCommentCommand',
"        \   'call ' . s:SID_PREFIX() . 'setCommentCommand("' . a:name . '")')
"  execute 'map' a:key '<Plug>(operator-comment-' . a:name . ')'
"endfunction
"
"function! s:setCommentCommand(command)
"  let s:comment_command = a:command
"endfunction
"
"function! s:doCommentCommand(motion_wiseness)
"  let v = operator#user#visual_command_from_wise_name(a:motion_wiseness)
"  execute 'normal! `[' . v . "`]\<Esc>"
"  call NERDComment(1, s:comment_command)
"endfunction
"
"call s:setCommentOperator('[Operator]c',       'norm')
"call s:setCommentOperator('[Operator]<Scace>', 'toggle')
"call s:setCommentOperator('[Operator]m',       'minimal')
"call s:setCommentOperator('[Operator]s',       'sexy')
"call s:setCommentOperator('[Operator]i',       'invert')
"call s:setCommentOperator('[Operator]y',       'yank')
"call s:setCommentOperator('[Operator]l',       'alignLeft')
"call s:setCommentOperator('[Operator]b',       'alignBoth')
"call s:setCommentOperator('[Operator]n',       'nested')
"call s:setCommentOperator('[Operator]u',       'uncomment')


"------------------------------------
" 補間 neocomplete
"------------------------------------

"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
    \ }

" キャッシュしないファイル名
let g:neocomplete#sources#buffer#disabled_pattern = '\.log\|\.log\.\|\.jax'
" 自動補完を行わないバッファ名
let g:neocomplete#lock_buffer_name_pattern = '\.log\|\.log\.\|.*quickrun.*\|.jax'

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" " Recommended key-mappings.
" " <CR>: close popup and save indent.
" inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
" function! s:my_cr_function()
  " return neocomplete#smart_close_popup() . "\<CR>"
  " " For no inserting <CR> key.
  " "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
" endfunction
" " <TAB>: completion.
" inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" " <C-h>, <BS>: close popup and delete backword char.
" inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
" inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" inoremap <expr><C-y>  neocomplete#close_popup()
" inoremap <expr><C-e>  neocomplete#cancel_popup()
" " Close popup by <Space>.
" "inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

" " For cursor moving in insert mode(Not recommended)
" "inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
" "inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
" "inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
" "inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplete#enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplete#enable_insert_char_pre = 1

" AutoComplPop like behavior.
let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
set completeopt+=longest
let g:neocomplete#enable_auto_select = 1
let g:neocomplete#disable_auto_complete = 1
inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

"------------------------------------
" neosnippet
"------------------------------------

" neosnippet "{{{

" snippetを保存するディレクトリを設定してください
let s:default_snippet = neobundle#get_neobundle_dir() . '/neosnippet/autoload/neosnippet/snippets' " 本体に入っているsnippet
let s:my_snippet = '~/.vim/snipmate-snippets/snippets' " 自分のsnippet
let g:neosnippet#snippets_directory = s:my_snippet
let g:neosnippet#snippets_directory = s:default_snippet . ',' . s:my_snippet
imap <silent><C-F>                <Plug>(neosnippet_expand_or_jump)
inoremap <silent><C-U>            <ESC>:<C-U>Unite snippet<CR>
nnoremap <silent><Space>e         :<C-U>NeoSnippetEdit -split<CR>
smap <silent><C-F>                <Plug>(neosnippet_expand_or_jump)
" xmap <silent>o                    <Plug>(neosnippet_register_oneshot_snippet)
"}}}

"" Define dictionary.
"let g:neocomplcache_dictionary_filetype_lists = {
"  \ 'default' : '',
"  \ 'ruby' : $HOME.'/.vim/snippets/ruby.snippets',
"  \ 'erb' : $HOME.'/.vim/snippets/erb.snippets',
"  \ 'html' : $HOME.'/.vim/snippets/html.snippets',
"  \ 'css' : $HOME.'/.vim/snippets/css.snippets',
"  \ 'javascript' : $HOME.'/.vim/snippets/javascript.snippets'
"  \ }

"------------------------------------
" surround.vim
"------------------------------------
"{{{
" s, ssで選択範囲を指定文字でくくる
nmap s <Plug>Ysurround
nmap ss <Plug>Yssurround
"}}}

"------------------------------------
" endwise.vim
"------------------------------------

"{{{
let g:endwise_no_mappings=1
"}}}

"------------------------------------
" mkd.vim
" Markdown-syntax
"------------------------------------
"{{{
autocmd BufRead,BufNewFile *.mkd setfiletype mkd
autocmd BufRead,BufNewFile *.md  setfiletype mkd
"}}}

"------------------------------------
" syntastic
"------------------------------------

"{{{
"
let g:syntastic_check_on_open=0 "ファイルを開いたときはチェックしない
let g:syntastic_check_on_save=1 "保存時にはチェック
let g:syntastic_auto_loc_list=1 "エラーがあったら自動でロケーションリストを開く
let g:syntastic_loc_list_height=6 "エラー表示ウィンドウの高さ
let g:syntastic_quiet_warnings = 0

let g:syntastic_mode_map = {
  \ 'mode': 'passive',
  \ 'active_filetypes': [''
  \    ],
  \ 'passive_filetypes': [
  \       'ruby', 'slim', 'eruby',
  \       'javascript', 'html', 'css', 'scss', 'sass'
  \    ]
  \ }
let g:syntastic_ruby_checkers = ['rubocop']
noremap <C-s> :<C-u>:SyntasticCheck<CR>

"エラー表示マークを変更
let g:syntastic_enable_signs=1
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'

" gem install ruby-lint
"au BufWritePost *.rb call RubyLint()
"au BufWritePost *.erb call RubyLint()
"au BufWritePost *.slim call RubyLint()
au FileType ruby noremap <C-l> :call RubyLint()<CR>

function! RubyLint()
  let result = system( &ft . ' -c ' . bufname(""))
  echo result
endfunction

"}}}

"------------------------------------
" align
"------------------------------------
"{{{
let g:Align_xstrlen=3
"}}}

"------------------------------------
" open-browser.vim
"------------------------------------
"{{{
let g:netrw_nogx = 1 " disable netrw's gx mapping.
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)
"}}}

"------------------------------------
" browserrefresh.vim
"------------------------------------
"{{{
let g:RefreshRunningBrowserDefault = 'chrome'
let g:RefreshRunningBrowserReturnFocus = 0
"}}}

"------------------------------------
" browserrefresh.vim
"------------------------------------
""  2html.vim {{{
""  http://nanasi.jp/articles/vim/2html_vim.html
""  :TOhtml
""  html_number_line 1:行番号を付ける 0:付けない undefined:numberオプションに応じる
" let html_number_lines = 0
""  html_use_css 1:use CSS undefined:not use CSS
" let html_use_css = 1
""  html_no_pre 1:not use pre element undefine:use pre element
""  use_xhtml 1:use xhtml
" let use_xhtml = 1
" " }}}

"------------------------------------
" yanktmp.vim
"------------------------------------

" map <silent> sy :call YanktmpYank()<CR>
" map <silent> sp :call YanktmpPaste_p()<CR>
" map <silent> sP :call YanktmpPaste_P()<CR>

"------------------------------------
" gundo.vim
"------------------------------------

"{{{
nmap U :<C-u>GundoToggle<CR>
"}}}

"------------------------------------
" tagbar.vim
"------------------------------------
"{{{
set tags=~/.tags
nmap <F8> :TagbarToggle<CR>

let g:alpaca_update_tags_config = {
      \ '_' : '-R --sort=yes',
      \ 'js' : '--languages=+js',
      \ '-js' : '--languages=-js,JavaScript',
      \ 'vim' : '--languages=+Vim,vim',
      \ '-vim' : '--languages=-Vim,vim',
      \ '-style': '--languages=-css,sass,scss,js,JavaScript,html',
      \ 'scss' : '--languages=+scss --languages=-css,sass',
      \ 'sass' : '--languages=+sass --languages=-css,scss',
      \ 'css' : '--languages=+css',
      \ 'java' : '--languages=+java $JAVA_HOME/src',
      \ 'ruby': '--languages=+Ruby',
      \ 'coffee': '--languages=+coffee',
      \ '-coffee': '--languages=-coffee',
      \ 'bundle': '--languages=+Ruby --languages=-css,sass,scss,js,JavaScript,coffee',
      \ }

"aug AlpacaUpdateTags
"  au!
"  au FileWritePost,BufWritePost * AlpacaTagsUpdate -style
"  " bundleのオプションは自動で追加して実行します。
"  au FileWritePost,BufWritePost Gemfile AlpacaTagsUpdateBundle
"  au FileReadPost,BufEnter * AlpacaTagsSet
"aug END
"}}}

"------------------------------------
" taglist
"------------------------------------
" set tags=~/.tags
" let Tlist_Show_One_File = 1 "現在編集中のソースのタグしか表示しない
" let Tlist_Exit_OnlyWiindow = 1 "taglist が最後のウインドウなら vim を閉じる
" let Tlist_Use_Right_Window = 1
" let Tlist_WinWidth = 40
" let Tlist_File_Fold_Auto_Close = 1
" let Tlist_Process_File_Always = 1
" let Tlist_Enable_Fold_Column = 0
" let Tlist_GainFocus_On_ToggleOpen = 1
" let Tlist_Sort_Type = "name"
" map <silent> <leader>tl :TlistToggle<CR>
"nnoremap <leader>t :Tlist<CR>

"------------------------------------
" vim-indent-guides.vim
"------------------------------------

"{{{
let g:indent_guides_auto_colors = 0
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1

augroup indentguides
    autocmd!
    autocmd VimEnter,Colorscheme * :hi IndentGuidesEven ctermbg=236
    autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd ctermbg=235
augroup END
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_color_change_percent=20
let g:indent_guides_space_guides=1
au FileType coffee,ruby,javascript IndentGuidesEnable
nmap <silent><Leader>ig <Plug>IndentGuidesToggle

" Tabs
nnoremap <Space>t t
nnoremap <Space>T T
nnoremap t <Nop>
nnoremap <silent> tc :<C-u>tabnew<CR>:tabmove<CR>
nnoremap <silent> tk :<C-u>tabclose<CR>
nnoremap <silent> tn :<C-u>tabnext<CR>
nnoremap <silent> tp :<C-u>tabprevious<CR>

" FuzzyFinder.vim
nnoremap <Space>f f
nnoremap <Space>F F
nnoremap f <Nop>
nnoremap <silent> fb :<C-u>FufBuffer!<CR>
nnoremap <silent> ff :<C-u>FufFile! <C-r>=expand('%:~:.')[:-1-len(expand('%:~:.:t'))]<CR><CR>
nnoremap <silent> fm :<C-u>FufMruFile!<CR>
nnoremap <silent> tb :<C-u>tabnew<CR>:tabmove<CR>:FufBuffer!<CR>
nnoremap <silent> tf :<C-u>tabnew<CR>:tabmove<CR>:FufFile! <C-r>=expand('#:~:.')[:-1-len(expand('#:~:.:t'))]<CR><CR>
nnoremap <silent> tm :<C-u>tabnew<CR>:tabmove<CR>:FufMruFile!<CR>
"}}}

"------------------------------------
" vim-textmanip
"------------------------------------

"{{{
" 選択したテキストの移動
vmap <C-j> <Plug>(Textmanip.move_selection_down)
vmap <C-k> <Plug>(Textmanip.move_selection_up)
vmap <C-h> <Plug>(Textmanip.move_selection_left)
vmap <C-l> <Plug>(Textmanip.move_selection_right)

" 行の複製
vmap <D-d> <Plug>(Textmanip.duplicate_selection_v)
nmap <D-d> <Plug>(Textmanip.duplicate_selection_n)
"}}}


"------------------------------------
" sass-compile
"------------------------------------
""{{{
"   let g:sass_compile_auto = 1
"   let g:sass_compile_cdloop = 5
"   let g:sass_compile_cssdir = ['css', 'stylesheet']
"   let g:sass_compile_file = ['scss', 'sass']
"   let g:sass_started_dirs = []
"   autocmd FileType less,sass  setlocal sw=2 sts=2 ts=2 et
"   au! BufWritePost * SassCompile
"}}}


"------------------------------------
" gitv.git
"------------------------------------

"{{{
autocmd FileType gitv call s:my_gitv_settings()
function! s:my_gitv_settings()
  setlocal iskeyword+=/,-,.
  nnoremap <silent><buffer> C :<C-u>Git checkout <C-r><C-w><CR>

  nnoremap <buffer> <Space>rb :<C-u>Git rebase <C-r>=GitvGetCurrentHash()<CR><Space>
  nnoremap <buffer> <Space>R :<C-u>Git revert <C-r>=GitvGetCurrentHash()<CR><CR>
  nnoremap <buffer> <Space>h :<C-u>Git cherry-pick <C-r>=GitvGetCurrentHash()<CR><CR>
  nnoremap <buffer> <Space>rh :<C-u>Git reset --hard <C-r>=GitvGetCurrentHash()<CR>

  nnoremap <silent><buffer> t :<C-u>windo call <SID>toggle_git_folding()<CR>1<C-w>w
endfunction

function! s:gitv_get_current_hash()
  return matchstr(getline('.'), '\[\zs.\{7\}\ze\]$')
endfunction

autocmd FileType git setlocal nofoldenable foldlevel=0
function! s:toggle_git_folding()
  if &filetype ==# 'git'
    setlocal foldenable!
  endif
endfunction
"}}}


"------------------------------------
" vim-gitgutter
"------------------------------------

nnoremap <silent> <leader>gg :<C-u>GitGutterToggle<CR>
nnoremap <silent> <leader>gh :<C-u>GitGutterLineHighlightsToggle<CR>


